It's traditional to define a Virtual Machine that bytecode runs on.  But that doesn't quite fit this plan.  Everything gets compiled to Forth, or executed by Forth, and the details will vary with the particular target Forth system.  There is no defined cell size, if your bytecode program contains no numbers larger than 16-bits and requires no calculations larger than 16-bits, it will run on 16-bit Forths that meet its other needs.  Etc.  If the Forth on the host and the target is the same version of the same Forth dialect there will be no compatibility problem.  Otherwise there may be.

The single current example uses 129 "primitives", Forth routines that are expected to be on the target system.  That leaves room for 127 one-byte tokens for an application.  Any application that didn't need all of the primitives could leave out whichever ones it didn't need, and you would have a new byte-code system that was partly tailored for that application.

Currently there is no use of VARIABLE or CONSTANT on the target.  In place of VARIABLE, the bytecode does   CREATE 0 ,   and in place of constant the bytecode does   CREATE ,   and each constant does   ADDRESS #N @  .  So to create a variable currently takes 5 bytes.  (Each number takes at least 3 byes, first the LIT then the count then the digits.  It would be easy to make numbers 0..255 or possibly -128..127 use the CHAR token and take only 2 bytes, reducing the length of VARIABLE to 4.)  To use the variable takes 2 bytes since addresses are double tokens.  To create a constant takes 2 bytes but to use it takes 3, first the double token for the address and then the @ token.  In exchange for making all the address accesses longer we save two tokens out of the token list, plus each named address.  Only two single-byte tokens to handle all the memory accesses.  One to assign a new base address, and one to declare that the next token is an address number.  If you don't anticipate many named memory locations in your code you could make a separate token for each variable or constant and reduce the size of the bytecode.

Currently all the core ANS Forth control-flow words are included, IF ELSE THEN BEGIN WHILE REPEAT UNTIL DO LOOP +LOOP LEAVE UNLOOP EXIT RECURSE  Most of these could possibly be replaced with tail-recursion and maybe one or two others.  That is very good for programmers who prefer that Forth style and whose code will be run on Forth systems that support it.  If we could make a tokenizer that converted that code to something a regular Forth system could handle, or that converts regular Forth control structures to something that either sort of Forth could handle, then we'd have something better than two incompatible bytecode approaches.


Designing your own bytecode system gives you two extra parameters to juggle.  There is memory size (on the target, which might be hardware and Forth system you don't know anything about, but you can deal with your application size on a defined system), there is speed (which you can't predict on an unknown target but you can on a known one), there is your convenience (your bytecode system might as well reflect your programming style), there is portability (you can make it run on more Forth dialects, but can you be sure whether it will run correctly?), there is size of the bytecode (on slow or expensive transmission lines or with giant bodies of code this gets more important), and there is keeping the number of tokens low enough that there will be room for your application words.  I find that I get quicker results when I work toward making it good enough, and improving it as I find the time or find the necessity.  
