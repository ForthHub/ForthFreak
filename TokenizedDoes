DOES> is hard to think about.  A DOES> that works only on the target to make named children is no problem, the tokenizer simply pass a DOES> token which the token compiler executes.

But a DOES> that works on byte-code isn't really DOES> at all, DOES> only acts on named commands created by CREATE .  We can get the same functional result by having an address and an execution token and a routine that puts the address on the stack and then executes the xt.  :NONAME ADDRESS SOME-TOKEN ;  4 tokens, 5 bytes.  (5 bytes because we implemented addresses as 2-byte tokens.)  The complication is all in the tokenizer, to turn a CREATE DOES> construction into this.  The complications come because the address may be partly allotted (and filled ) before and partly after the DOES> execution.  I haven't done it yet in this context.  Given a Harvard architecture it doesn't look real hard, but it looks a little complicated to do it so it works everywhere.
