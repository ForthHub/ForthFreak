If a word doesn't parse, the tokenizer can simply send its token to execute or be compiled.  Almost all the work can be done later by the token compiler which knows what needs to be done.  But a word that does parse has to parse on the tokenizer first, and the tokenizer must do whatever manipulation is required so the token compiler can do the right thing.

Usually the tokenizer can simply put the string into the byte code for the token compiler to handle later.  Even then we have some issues because we can't simply assume the byte code is in an input buffer.  It may be dribbling in a token at a time.  The general approach is to put the name of the appropriate command into a buffer followed by the string from byte code (as it arrives) and then EVALUATE the whole thing.  But if we have a command that puts .( HELLO) into a buffer and evaluates it, that command isn't the same thing as .( .  It's a command that parses byte code, puts it into a buffer, etc.  So for each parsing command we could have two different versions, one to parse byte code and one to parse the input buffer.  At present we handle that by using DEFER on such words in the token compiler, and we will switch what they do when we switch from parsing bytecode to parsing text or vice versa.  


If you want to make your own parsing words to build into bytecode and execute on bytecode, at present you have to add them to the tokenizer.  Tell the tokenizer what parsing they do and make the tokenizer provide the strings for them to parse.  
