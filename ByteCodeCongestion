People sometimes complain that byte code is inherently limited. With only 256 tokens you can't do much. This is not true. You can define one number to serve as the first half of a two-byte token. Then you have 255 one-byte tokens and 256 two-byte tokens. Or you could have two such headers, then you have 254 one-byte tokens and 512 two-byte tokens. And so on. When you complete that process you would have 65536 two-byte tokens which is not a small system at all, for only double the space per token.

Here is another approach for larger systems -- divide them into smaller modules. For each module, mark some of the routines for export. Then when the byte code gets compiled the exported routines are added to the dictionary. Each succeeding module can ignore all the routines of the previous module except the imports it needs, for which it gets byte codes. So the number of byte codes used by any one module stays low and rises slowly with the level of abstraction. 
